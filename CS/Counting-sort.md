# 계수 정렬(Counting Sort)

비교정렬(comparison sort)의 시간복잡도의 하한은 O(nlogn) 이다.

계수 정렬은 non-comparison sort 기법이며, 정렬에 드는 계산복잡도을 O(n) 으로 낮추기 위한 알고리즘이다.

정확히 말하면, 정렬할 수 중 가장 큰 값을 k라고 했을 때 계수정렬의 계산복잡도는 O(n+k) 이다.

따라서 정렬할 수의 최대값이 낮을때 효과적이며, k의 값이 매우 커지게 되면 다른 정렬 알고리즘에 비해 성능이 떨어진다.

>  가령 k가 n^2보다 커지게 되는 경우 선택, 삽입, 버블 정렬 등의 기본적인 정렬 알고리즘보다도 속도가 느리게 된다.

## 수행 과정 

계수 정렬은 정렬하려는 수들의 개수를 세어 누적합을 구한 뒤, 누적합에 따라 수를 정렬하는 것이다.

이 때, 정렬 대상의 원소는 모두 양의 정수여야한다.

1. 정렬 대상에서 중복되는 값의 개수를 구하여 저장한다. 
2. 저장한 중복 횟수를 누적합으로 바꾼다. 
3. 정렬 대상을 역순으로 순회하며 결과를 출력한다. 

### 예시 
```js
// 아래의 배열을 정렬 
arr = {2, 0, 2, 0, 4, 1, 5, 5, 2, 0, 2, 4, 0, 4, 0, 3} 
```

- 배열 arr 에 들어있는 요소들이 몇 개씩 들어있는지 파악한다.
  ```js
  cnt = {5, 1, 4, 1, 3, 2} 
  cnt[0] 0의 개수이다. 배열 A에 0이 5개 들어있기 때문에 cnt[0] 의 값은 5가 된다.
  ```

- 배열 cnt 의 요소값에 이전 요소들의 누적값을 더해준다.
  ```js
  cnt = {5, 6, 10, 11, 14, 16}
  cnt[1] = cnt[0] + cnt[1] // 5 + 1 
  cnt[2] = cnt[0] + cnt[1] + cnt[2] // 5 + 1 + 4 
  cnt[3] = cnt[0] + cnt[1] + cnt[2] + cnt[3] // 5 + 1 + 4 + 1 
  ... 
  ```

  이 과정을 거치지 않고, 순서대로 출력하면 된다고 생각할 수 있다.

  이 경우 정렬 대상의 최대값에 큰 영향을 받기 때문에 오히려 비효율적이다.

  non-comparison 방식으로 정렬을 하기 위해서는 배열 cnt 의 길이가 정렬 대상의 최대값과 같아야하기 때문이다.

  또한, 누적합을 더하는 방식을 이용하면 stable한 상태를 유지할 수 있는데, 이는 기수정렬에서 설명할것이다.

- 배열 arr 의 요소값을 역순으로 저장한다.
  ```c
  int[arr.length] result; // 결과값 배열의 크기는 정렬 대상과 같아야 한다. 
  for(i = arr.length-1; i>=0; i--){
    result[cnt[arr[i]] = arr[i];
    /* 배열 cnt의 값이 result의 인덱스가 되기 때문에,
     * 값을 저장한 수의 누적값을 감소시켜야 한다.
     */
    cnt[arr[i]]--; 
  }
  ```
  
---

#### References 
- [Counting Sort : 계수 정렬 ](https://bowbowbow.tistory.com/8)
- [카운팅 정렬, 래딕스 정렬 ](https://ratsgo.github.io/data%20structure&algorithm/2017/10/16/countingsort/)
