# **4장 - Threads & Concurrency**

현대적인 운영 체제들은 한 개의 Process가 여러 Thread를 다룰 수 있도록 하는 기능을 제공한다. 4장 Thread & Concurrency에서는 아래 5가지 목표에 대해서 다루게 된다.

1. 다중 스레드 컴퓨터 시스템의 기초를 이루는 CPU의 기본 단위인 스레드를 소개한다.
2. 다중 스레드 프로그래밍과 관련된 여러 쟁점을 검토한다.
3. 암시적 스레딩을 지원하는 몇 가지 전략(threading pool, fork-join, Grand Central Dispatch)을 탐구한다.
4. Windows, Linux의 스레드 지원에 대해 알아본다.
5. Pthreads API 및 Windows와 Java 스레드 라이브러리에 대해 논의한다.

## **4.1 Overview**

스레드는 CPU 이용의 기본 단위이다. 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다. 스레드는 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션 등의 운영체제 자원들을 공유한다. 프로세스에는 **싱글 스레드**와 **멀티 스레드**가 존재한다.

### **4.1.1 Motivation**

최신 컴퓨터와 모바일 장치에서 실행되는 대부분의 소프트웨어 응용 프로그램은 다중 스레드이다. 어플리케이션은 일반적으로 여러 개의 제어 스레드가 있는 별도의 프로세스로 구현된다. 멀티스레드 어플리케이션의 몇 가지 예는 아래와 같다.

- 이미지 컬렉션에서 썸네일을 만드는 응용 프로그램은 별도의 스레드를 사용하여 개별 이미지에서 썸네일을 생성할 수 있음

- 다른 스레드가 네트워크에서 데이터를 검색하는 동안 웹 브라우저에는 하나의 스레드가 디스플레이 이미지 또는 텍스트를 담당

- 워드 프로세서는 그래픽을 표시하는 스레드, 사용자의 키 입력에 응답하는 다른 스레드, 백그라운드에서 철자 및 문법 검사를 수행하는 세 번째 스레드를 포함할 수 있음

하나의 응용 프로그램이 여러 개의 비슷한 작업을 수행할 필요가 있는 상황에서 멀티 스레딩은 좋은 방법이다. 다른 해결책은 서버의 요청을 받아들이는 하나의 프로세스로 동작하게 하는 것이다. 즉 서버에게 서비스 요청이 들어오면, 프로세스는 그 요청을 수행할 별도의 프로세스를 생성하는 것이다. 이 방식은 스레드의 다중화 전에는 매우 보편적인 방법이었다.

그러나 프로세스 생성 작업은 매우 많은 시간을 소비하고 많은 자원을 필요로 하는 일이다. 하지만 새 프로세스가 해야 할 일이 기존 프로세스가 하는 일과 동일하므로 대부분은 하나의 프로세스 안에 여러 스레드를 만들어나가는 것이 더 효율적이다. 또한, 현재의 운영체제 커널은 다중화되어 있다. 커널 안에 다수의 스레드가 동작하고 각 스레드는 장치 또는 인터럽트 처리 등의 특정 작업을 수행한다.

<img width="879" alt="Single-threaded and multithreaded processes" src="https://user-images.githubusercontent.com/16266103/120910509-78553980-c6ba-11eb-9527-e89dd0b58a7e.png">

<img width="885" alt="Multithreaded server architecture" src="https://user-images.githubusercontent.com/16266103/120910501-61164c00-c6ba-11eb-9065-1fb2e86775d6.png">

### **4.1.2 Benefits**

멀티스레드 프로그래밍의 이점은 크게 4가지이다.

1. Responsiveness(반응성) : Process의 일부가 차단된 경우, 특히 사용자 인터페이스에 중요한 작업을 계속 실행할 수 있음
2. Resource Sharing(자원 공유) : Thread는 Process의 리소스를 공유하며, shared memory 혹은 message passing보다 쉬움
3. Economy(효율성) : Thread는 Process 생성보다 비용이 적게 들고 더욱 빠르게 생성할 수 있으며, Context Switching보다 오버헤드가 낮음
4. Scalability(확장성) : 멀티스레딩의 이점은 스레드가 서로 다른 코어에서 병렬로 실행되는 멀티프로세서 아키텍처에서 극대화 되며, 단일 스레드 프로세스는 사용 가능한 프로세서 수에 관계없이 한 프로세서에서만 실행할 수 있음

## **4.2 Multicore Programming**

단일 프로세스 칩에 여러 코어를 달아 운영 체제에서 별개의 CPU로 인식하게 하는 것을 **multicore** 시스템이라 한다. 동시성 시스템은 여러 작업을 수행할 수 있게 하는 것이고 병렬화는 여러 작업을 동시에 수행하는 것이다. 즉, 병렬화 없이도 동시성을 이룰 수 있다. 싱글 코어에서는 이는 context switching으로 이루어졌다.

하나의 코어는 한 번에 오직 하나의 스레드만 실행할 수 있기 때문에 단일 코어 시스템상에서 병행성은 단순히 스레드의 실행이 시간에 따라 교대로 실행된다는 것을 의미한다. 그러나 여러 코어를 가진 시스템에서는 시스템이 개별 스레드를 각 코어에 배정할 수 있기 때문에 병행성은 스레드들이 병령적으로 실행될 수 있다는 것을 뜻한다.

<img width="788" alt="Concurrent execution on a single-core system" src="https://user-images.githubusercontent.com/16266103/120910518-9458db00-c6ba-11eb-984e-b7c122a67af5.png">

### **4.2.1 Programming Challenges**

multicore system의 프로그래밍 난점은 아래 5가지이다.

<img width="556" alt="Parallel execution on a multicore system" src="https://user-images.githubusercontent.com/16266103/120910530-a63a7e00-c6ba-11eb-8e10-ee76a82972d9.png">

1. Identifying tasks(작업 식별) : 동시 작업으로 나눌 수 있는 영역을 찾기 위한 응용 프로그램을 검토하는 작업이 포함되며, 이상적으로는 작업이 서로 독립적이므로 개별 코어에서 병렬로 실행될 수 있음
2. Balance(균형 잡기) : 병렬로 실행할 수 있는 작업을 식별하는 동안, 프로그래머는 작업이 동일한 값의 동일한 작업을 수행하도록 보장해야 하며, 경우에 따라서는 특정 task가 다른 task만큼 전체 프로세스에 많은 가치를 부여하지 않을 수 있음
3. Data splitting(데이터 분할) : 애플리케이션이 개별 task로 분할되는 것과 마찬가지로, 작업에 의해 액세스되고 조작되는 데이터는 개별 코어에서 실행되도록 분할해야 함
4. Data dependency(데이터 의존성) : 작업에서 액세스하는 데이터는 둘 이상의 작업 간의 종속성을 검사해야 하며, 한 작업이 다른 작업의 데이터에 의존하는 경우, 프로그래머는 작업의 실행이 데이터 종속성을 수용하도록 동기화되어야 함(6장에서 자세히 다루게 됨)
5. Testing and debugging(테스팅과 디버깅) : 프로그램이 여러 코어에서 병렬로 실행되면 다양한 실행 경로를 사용할 수 있으며, 이러한 동시성 프로그램을 테스트하고 디버깅하는 것은 단일 스레드 응용프로그램을 테스트하고 디버깅하는 것보다 본질적으로 더 어려움

#### AMDAHL’S LAW
Amdahl의 법칙은 직렬(비병렬) 및 병렬 구성 요소를 모두 갖춘 애플리케이션에 컴퓨팅 코어를 추가함으로써 얻을 수 있는 잠재적 성능 향상을 나타내는 공식이다.

예를 들어, 75%의 병렬 및 25%의 직렬 애플리케이션을 사용한다고 가정하자. 두 개의 프로세싱 코어가 있는 시스템에서 이 애플리케이션을 실행하면 1.6배의 속도를 얻을 수 있다. 두 개의 코어를 추가하면(총 4개), 속도가 2.28배 빨라진다. 아래 그래프는 여러 다른 시나리오에서 Amdahl의 법칙을 보여준다.

<img width="594" alt="AMDAHL’S LAW" src="https://user-images.githubusercontent.com/16266103/121798906-eb832080-cc63-11eb-9521-7bf55f32d2c3.png">

Amdahl의 법칙에 대한 한 가지 흥미로운 사실은 N이 무한대에 가까워질수록 속도가 1µS로 수렴된다는 것이다. 예를 들어 애플리케이션의 50%가 연속적으로 수행되는 경우, 추가되는 처리 코어 수에 관계없이 최대 속도 상승은 2배이다. 이것은 Amdahl의 법칙에 대한 기본 원리이다(애플리케이션의 직렬 부분은 컴퓨팅 코어를 더 추가함으로써 우리가 얻는 성능에 불균형적인 영향을 미칠 수 있다)

### **4.2.2 Types of Parallelism**

Parallelism에는 Data parallelism(데이터 병렬화), Task Parallelism(작업 병렬화) 2가지가 있으며 서로 상호배타적이지 않다.

<img width="667" alt="Data and task parallelism" src="https://user-images.githubusercontent.com/16266103/120910548-b6525d80-c6ba-11eb-93f4-1c0e7547f450.png">

#### Data parallelism(데이터 병렬화)

- 동일한 데이터의 다른 하위 집합에서 동일한 작업을 수행

- 동기식 연산(Synchronous computation)을 수행

- 모든 데이터 세트에서 동작하는 실행 스레드가 하나뿐이기 때문에 속도 향상은 더욱 빠름

- Data parallelism(데이터 병렬화)의 양은 입력 크기에 비례함

- 멀티프로세서 시스템의 최적 부하 균형을 위해 설계됨

#### Task parallelism(작업 병렬화)

- 동일하거나 다른 데이터에 대해 다른 작업을 수행

- 비동기 연산(Asynchronous computation)을 수행

- 각 프로세서가 동일하거나 다른 데이터 집합에서 서로 다른 스레드 또는 프로세스를 실행하므로 속도 향상은 적음

- Task parallelism(작업 병렬화)의 양은 독립적인 업무의 수에 비례함

<img width="502" alt="User and kernal threads" src="https://user-images.githubusercontent.com/16266103/120910562-cbc78780-c6ba-11eb-989b-9ceb9b86956e.png">


<details>
<summary> 질문(2021.06.13) </summary>

- 암달의 법칙이 GPU에 적용되지 않는 이유
-> CPU는 Task(규모 있는 작업)를 돌리는 게 목적이지만 GPU는 단순한 걸 하나씩(array의 각 파트 병렬 연산) 병렬로 연산하는 작업을 하기 때문이다.

- GPU를 이용하려면 데이터 병렬화를 해야 하는가?
-> 데이터를 나눠서 작업할 때 한 작업이 다른 작업이 계산하고 있는 데이터를 건들지 않는 것이 중요하다. 따라서 단위를 잘 쪼갤 수 있으면 된다.

- GPU 그래픽 그릴 때 픽셀 단위로 병렬화의 그 단위인가?
-> 픽셀은 최종적으로 비춰지는 단위이다. 픽셀에 맞추지 않은 채로 계산 후 픽셀에 맞춰서 뿌려준다.(텍스쳐, 폴리곤) 이것을 GPU 파이프라이닝이라고 한다.

- 데이터 병렬화와 함수형 프로그래밍
-> 순수함수가 필요한 이유는 데이터 병렬화에 효율적이며 데이터 병렬화가 보장되기 때문이다.

</details>